}
j<-1
tmp_cross <- config$Crosses[j]
# Get today data for classifier for this cross
inp_params$Cross <- tmp_cross
tmp_today_data <- Get_SubsetData_ForPrediction(inp_data = model_xdata[i, ], inp_params = inp_params)  # Current day xdata
tmp_today_data
tail(classifiers_per_cross[[tmp_cross]], 1)
tmp_today_predictions <- Get_ClassifierPrediction(tail(classifiers_per_cross[[tmp_cross]], 1), tmp_today_data, inp_params)   # Use latest classifier here (to take in to account any re-fitting done)
tail(classifiers_per_cross[[tmp_cross]], 1)
classifiers_per_cross[[tmp_cross]][[length(classifiers_per_cross[[tmp_cross]])]]
tail(classifiers_per_cross[[tmp_cross]], 1, addrownums = FALSE)
tail(classifiers_per_cross[[tmp_cross]], 1, addrownums = TRUE)
value(tail(classifiers_per_cross[[tmp_cross]], 1))
unlist(tail(classifiers_per_cross[[tmp_cross]], 1))
tail(classifiers_per_cross[tmp_cross], 1)
tmp_today_predictions <- Get_ClassifierPrediction(classifiers_per_cross[[tmp_cross]][[length(classifiers_per_cross[[tmp_cross]])]], tmp_today_data, inp_params)   # Use latest classifier here (to take in to account any re-fitting done)
tmp_today_predictions
source('config.R')
my_params <- list("Model_XDataFile" = "Data/SmallTestFile.csv",
"XData_To_Use" = c("Returns", "PC1", "PC2"),
"Fit_Window" = 250,
"Rolling_Window_Performance" = 10,
"Prediction_Adjust_Factor" = 0.5,
"AdjustPredictedPositions" = TRUE,
"Classifier_Type" = "lda",
"Refit_Classifier_Periodicity" = NA)
backtest_results <- Backtest_ClassifierAlgo(my_params)
backtest_results$CurrencyTarget_Returns[is.na(backtest_results$CurrencyTarget_Returns)] <- 0
for (i in 1:ncol(backtest_results$CurrencyTarget_Returns)) {
plot(cumsum(backtest_results$CurrencyTarget_Returns[[i]]), type="l", main=colnames(backtest_results$CurrencyTarget_Returns)[i])
}
backtest_results$Cross_Classifiers
lapply(backtest_results$Cross_Classifiers, length)
my_params <- list("Model_XDataFile" = "Data/SmallTestFile.csv",
"XData_To_Use" = c("Returns", "PC1", "PC2"),
"Fit_Window" = 250,
"Rolling_Window_Performance" = 10,
"Prediction_Adjust_Factor" = 0.5,
"AdjustPredictedPositions" = TRUE,
"Classifier_Type" = "lda",
"Refit_Classifier_Periodicity" = 50)
backtest_results2 <- Backtest_ClassifierAlgo(my_params)
backtest_results2$Cross_Classifiers
lapply(backtest_results2$Cross_Classifiers, length)
backtest_results2$Cross_Classifiers$EURUSD
names(backtest_results2$Currency_Returns)
backtest_results2$Currency_Returns$NOK
cumsum(backtest_results2$Currency_Returns$NOK)
cumsum(backtest_results2$Currency_Returns$NOK, na.rm=TRUE)
tmp <- backtest_results2$Currency_Returns$NOK
tmp[is.na(tmp)] <- 0
cumsum(tmp)
tmp_ccy <- "GBP"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "EUR"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "AUD"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "NZD"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "CAD"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "CHF"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "NOK"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "SEK"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "JPY"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
my_params <- list("Model_XDataFile" = "Data/SmallTestFile.csv",
"XData_To_Use" = c("Returns", "PC1", "PC2"),
"Fit_Window" = 250,
"Rolling_Window_Performance" = 10,
"Prediction_Adjust_Factor" = 0.5,
"AdjustPredictedPositions" = TRUE,
"Classifier_Type" = "lda",
"Refit_Classifier_Periodicity" = NA)
backtest_results <- Backtest_ClassifierAlgo(my_params)
tmp_ccy <- "JPY"; tmp <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0; plot(cumsum(tmp), type="l")
tmp_ccy <- "JPY"
tmp <- backtest_results$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0
tmp2 <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp2[is.na(tmp2)] <- 0;
plot(cumsum(tmp), type="l", main=tmp_ccy)
lines(cumsum(tmp2), col="red", lty=2)
tmp_ccy <- "EUR"
tmp <- backtest_results$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0
tmp2 <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp2[is.na(tmp2)] <- 0;
plot(cumsum(tmp), type="l", main=tmp_ccy)
lines(cumsum(tmp2), col="red", lty=2)
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main=tmp_ccy)
lines(cumsum(tmp2), col="red", lty=2)
tmp_ccy <- "GBP"
tmp <- backtest_results$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0
tmp2 <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp2[is.na(tmp2)] <- 0;
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main=tmp_ccy)
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c("Without Re-fit", "With Re-fit"), col=1:2, lty=1:2)
tmp_ccys <- config$Currencies
for (i in seq_along(tmp_ccys)) {
tmp_ccy <- tmp_ccys[i]
tmp <- backtest_results$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0
tmp2 <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp2[is.na(tmp2)] <- 0;
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main=tmp_ccy)
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c("Without Re-fit", "With Re-fit"), col=1:2, lty=1:2)
}
tmp <- rowSums(backtest_results$Currency_Returns, na.rm=TRUE); tmp[is.na(tmp)] <- 0
tmp2 <- rowSums(backtest_results2$Currency_Returns, na.rm=TRUE); tmp2[is.na(tmp2)] <- 0
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main="Aggregate")
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c("Without Re-fit", "With Re-fit"), col=1:2, lty=1:2)
Backtest_ClassifierAlgo <- function(inp_params) {
# Perform a backtest of a specified classifier type using specified backtest parameters.
# Parameter list must contain the following objects:
# Model_XDataFile, XData_To_Use, Fit_Window, Rolling_Window_Performance, Prediction_Adjust_Factor, AdjustPredictedPositions
# Classifier_Type, Refit_Classifier_Periodicity
#   inp_params <- my_params
#   inp_params <- list("Model_XDataFile" = "Data/SmallTestFile.csv",
#                      "XData_To_Use" = c("Returns", "PC1", "PC2"),
#                      "Fit_Window" = 250,
#                      "Rolling_Window_Performance" = 10,
#                      "Prediction_Adjust_Factor" = 0.5,
#                      "AdjustPredictedPositions" = TRUE,
#                      "Classifier_Type" = "lda",
#                      "Refit_Classifier_Periodicity" = NA)
outp_results <- list()  # List of backtest results and various calculated objects
classifiers_per_cross <- list()  # List object to hold trained classifiers for each cross, at each time (if using re-fitting)
# Add the backtest parameters list to the output list for user information
outp_results$Backtest_Parameters <- inp_params
# Import the XData file
# ---
Logger("Importing XData...")
model_xdata <- Get_XData(inp_params$Model_XDataFile)
outp_results$XData <- model_xdata
# ---
# Perform the initial classifier model fitting
# ---
Logger("Fitting initial classifier models...")
tmp_fit_date <- model_xdata$Datetime[inp_params$Fit_Window]
for (i in seq_along(config$Crosses)) {
cat("Currently on cross:", config$Crosses[i], "\n")
inp_params$Cross <- config$Crosses[i]
tmp_training_data <- head(model_xdata, inp_params$Fit_Window)
tmp_data <- Get_SubsetData_ForClassification(inp_data = tmp_training_data, inp_params = inp_params)
classifiers_per_cross[[config$Crosses[i]]][[tmp_fit_date]] <- Fit_Classifier(inp_data = tmp_data, inp_params = inp_params)
}
# ---
# Iterate through all data
# ---
Logger("Performing backtest...")
# Initialise some data.frames to store data throughout iterations
tmp_predictions_raw <- data.frame(matrix(NA, nrow(model_xdata), length(config$Crosses), dimnames=list(model_xdata$Datetime, config$Crosses)))
tmp_predictions_adj <- data.frame(matrix(NA, nrow(model_xdata), length(config$Crosses), dimnames=list(model_xdata$Datetime, config$Crosses)))
tmp_predictions_accuracy <- data.frame(matrix(NA, nrow(model_xdata), length(config$Crosses), dimnames=list(model_xdata$Datetime, config$Crosses)))
tmp_predictions_accuracy_rolling <- data.frame(matrix(NA, nrow(model_xdata), length(config$Crosses), dimnames=list(model_xdata$Datetime, config$Crosses)))
tmp_currency_targets <- data.frame(matrix(NA, nrow(model_xdata), length(config$Currencies), dimnames=list(model_xdata$Datetime, config$Currencies)))
tmp_currency_returns <- data.frame(matrix(NA, nrow(model_xdata), length(config$Currencies), dimnames=list(model_xdata$Datetime, config$Currencies)))
# Extract concise array of cross returns for ease of use in backtester
cross_returns_array <- model_xdata[, c(1, match(paste(config$Crosses, ".1_Return", sep=""), names(model_xdata)))]  # Array of cross returns
colnames(cross_returns_array) <- c("Datetime", config$Crosses)  # Put better headers (excluding the .1_Return bit)
# Begin iterations through model_xdata (beyond initial classifier training data range), generating targets
time_since_fit <- 0
for (i in (inp_params$Fit_Window + 1):nrow(model_xdata)) {
# Progress print at set intervals
# ---
if (i %% 50 == 0)
Logger(paste("On date ", i, " of ", nrow(model_xdata), " ... ", sep=""))
# ---
# Section here to do something special like re-fit a model if certain criteria met
# ---
if (!is.na(inp_params$Refit_Classifier_Periodicity)) {  # Refit the classifier models here
# This should all live in a separate method, just to be called now
if (time_since_fit == inp_params$Refit_Classifier_Periodicity) {
Logger("Re-fitting classifier models...")
tmp_fit_date <- model_xdata$Datetime[i]
for (k in seq_along(config$Crosses)) {
cat("Currently on cross:", config$Crosses[k], "\n")
inp_params$Cross <- config$Crosses[k]
tmp_training_data <- model_xdata[(i - inp_params$Fit_Window):(i - 1), ]
tmp_data <- Get_SubsetData_ForClassification(inp_data = tmp_training_data, inp_params = inp_params)
classifiers_per_cross[[config$Crosses[k]]][[tmp_fit_date]] <- Fit_Classifier(inp_data = tmp_data, inp_params = inp_params)
}
time_since_fit <- 0
}
}
# ---
# Use xdata to classify the next day return
# ---
for (j in seq_along(config$Crosses)) {
tmp_cross <- config$Crosses[j]
# Get today data for classifier for this cross
inp_params$Cross <- tmp_cross
tmp_today_data <- Get_SubsetData_ForPrediction(inp_data = model_xdata[i, ], inp_params = inp_params)  # Current day xdata
# Get prediction and record the result as a 1 (buy) or -1 (sell)
tmp_today_predictions <- Get_ClassifierPrediction(classifiers_per_cross[[tmp_cross]][[length(classifiers_per_cross[[tmp_cross]])]], tmp_today_data, inp_params)   # Use latest classifier here (to take in to account any re-fitting done)
if (tmp_today_predictions$class == "B")
tmp_predictions_raw[i, j] <- 1
else if (tmp_today_predictions$class == "S")
tmp_predictions_raw[i, j] <- -1
# Record whether this was a correct prediction using next day cross return (if not already last row)
if (i < nrow(model_xdata))
tmp_predictions_accuracy[i, j] <- as.numeric(sign(tmp_predictions_raw[i, j]) == sign(cross_returns_array[[tmp_cross]][i + 1]))
# Calculate the rolling window prediction accuracy ratio (if sufficient predictions made) and create a performance-adjusted prediction
if (i > (inp_params$Fit_Window + inp_params$Rolling_Window_Performance)) {
tmp <- tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), j]  # Window of prediction accuracies for this cross
tmp_predictions_accuracy[i, j] <- sum(tmp == 1) / inp_params$Rolling_Window_Performance  # Accuracy ratio
tmp_predictions_adj[i, j] <- tmp_predictions_raw[i, j] * (1 + inp_params$Prediction_Adjust_Factor * (tmp_predictions_accuracy[i, j] - 0.5) / 0.5)
}
}
# ---
# Aggregate predictions to get currency level targets
# ---
for (j in seq_along(config$Currencies)) {
tmp_ccy <- config$Currencies[j]  # This currency
tmp_cxs_as_base <- config$Crosses[grep(tmp_ccy, substr(config$Crosses, 1, 3))]  # Crosses with the target ccy as base
tmp_cxs_as_quote <- config$Crosses[grep(tmp_ccy, substr(config$Crosses, 4, 6))]  # Crosses with the target ccy as quote
tmp_pos_as_base <- tmp_pos_as_quote <- 0  # Default values at 0
if (!all(is.na(tmp_predictions_adj[tmp_cxs_as_base][i, ])))
tmp_pos_as_base <- sum(tmp_predictions_adj[tmp_cxs_as_base][i, ], na.rm=TRUE)  # Sum of predictions where currency is base
if (!all(is.na(tmp_predictions_adj[tmp_cxs_as_quote][i, ])))
tmp_pos_as_quote <- sum(tmp_predictions_adj[tmp_cxs_as_quote][i, ], na.rm=TRUE)  # Sum of predictions where currency is quote
tmp_currency_targets[i, j] <- tmp_pos_as_base - tmp_pos_as_quote  # Total aggregated currency holding ("as quote" sum contributes as negative)
}
# ---
# Get resulting return from the target currency holdings
# ---
if (i < nrow(model_xdata)) {
for (j in seq_along(config$Currencies)) {
tmp_ccy <- config$Currencies[j]
if (tmp_ccy == "USD") {
tmp_currency_returns[i, j] <- 0
} else if (tmp_ccy %in% c("EUR", "GBP", "AUD", "NZD")) {
tmp_currency_returns[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * tmp_currency_targets[i, j]
} else {
tmp_currency_returns[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * tmp_currency_targets[i, j] * -1
}
}
}
# ---
time_since_fit <- time_since_fit + 1
}
Logger("Done!", inp_new_line = FALSE)
# Add the fitted classifiers object to return list for user information
outp_results$Cross_Classifiers <- classifiers_per_cross
# Add some of the data arrays to the return list for user
outp_results$Cross_Predictions <- tmp_predictions_adj
outp_results$Cross_Predictions_Accuracy <- tmp_predictions_accuracy
outp_results$Cross_Predictions_Accuracy_Rolling <- tmp_predictions_accuracy_rolling
outp_results$Currency_Targets <- tmp_currency_targets
outp_results$Currency_Returns <- tmp_currency_returns
return (outp_results)
}
my_params <- list("Backtest_Tag" = "NoAdj,NoRefit",
"Model_XDataFile" = "Data/SmallTestFile.csv",
"XData_To_Use" = c("Returns", "PC1", "PC2"),
"Fit_Window" = 250,
"Rolling_Window_Performance" = 10,
"Prediction_Adjust_Factor" = 0.5,
"AdjustPredictedPositions" = FALSE,
"Classifier_Type" = "lda",
"Refit_Classifier_Periodicity" = NA)
backtest_results <- Backtest_ClassifierAlgo(my_params)
my_params <- list("Backtest_Tag" = "NoAdj,WithRefit50",
"Model_XDataFile" = "Data/SmallTestFile.csv",
"XData_To_Use" = c("Returns", "PC1", "PC2"),
"Fit_Window" = 250,
"Rolling_Window_Performance" = 10,
"Prediction_Adjust_Factor" = 0.5,
"AdjustPredictedPositions" = FALSE,
"Classifier_Type" = "lda",
"Refit_Classifier_Periodicity" = NA)
backtest_results2 <- Backtest_ClassifierAlgo(my_params)
tmp_ccys <- config$Currencies
for (i in seq_along(tmp_ccys)) {
tmp_ccy <- tmp_ccys[i]
tmp <- backtest_results$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0
tmp2 <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp2[is.na(tmp2)] <- 0;
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main=tmp_ccy)
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c(backtest_results$Backtest_Tag, backtest_results2$Backtest_Tag), col=1:2, lty=1:2)
}
tmp <- rowSums(backtest_results$Currency_Returns, na.rm=TRUE); tmp[is.na(tmp)] <- 0
tmp2 <- rowSums(backtest_results2$Currency_Returns, na.rm=TRUE); tmp2[is.na(tmp2)] <- 0
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main="Aggregate")
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c(backtest_results$Backtest_Tag, backtest_results2$Backtest_Tag), col=1:2, lty=1:2)
tmp_ccys <- config$Currencies
for (i in seq_along(tmp_ccys)) {
tmp_ccy <- tmp_ccys[i]
tmp <- backtest_results$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0
tmp2 <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp2[is.na(tmp2)] <- 0;
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main=tmp_ccy)
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c(backtest_results$Backtest_Parameters$Backtest_Tag, backtest_results2$Backtest_Parameters$Backtest_Tag), col=1:2, lty=1:2)
}
tmp <- rowSums(backtest_results$Currency_Returns, na.rm=TRUE); tmp[is.na(tmp)] <- 0
tmp2 <- rowSums(backtest_results2$Currency_Returns, na.rm=TRUE); tmp2[is.na(tmp2)] <- 0
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main="Aggregate")
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c(backtest_results$Backtest_Parameters$Backtest_Tag, backtest_results2$Backtest_Parameters$Backtest_Tag), col=1:2, lty=1:2)
my_params <- list("Backtest_Tag" = "NoAdj,WithRefit50",
"Model_XDataFile" = "Data/SmallTestFile.csv",
"XData_To_Use" = c("Returns", "PC1", "PC2"),
"Fit_Window" = 250,
"Rolling_Window_Performance" = 10,
"Prediction_Adjust_Factor" = 0.5,
"AdjustPredictedPositions" = FALSE,
"Classifier_Type" = "lda",
"Refit_Classifier_Periodicity" = 50)
backtest_results2 <- Backtest_ClassifierAlgo(my_params)
tmp_ccys <- config$Currencies
for (i in seq_along(tmp_ccys)) {
tmp_ccy <- tmp_ccys[i]
tmp <- backtest_results$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0
tmp2 <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp2[is.na(tmp2)] <- 0;
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main=tmp_ccy)
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c(backtest_results$Backtest_Parameters$Backtest_Tag, backtest_results2$Backtest_Parameters$Backtest_Tag), col=1:2, lty=1:2)
}
tmp <- rowSums(backtest_results$Currency_Returns, na.rm=TRUE); tmp[is.na(tmp)] <- 0
tmp2 <- rowSums(backtest_results2$Currency_Returns, na.rm=TRUE); tmp2[is.na(tmp2)] <- 0
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main="Aggregate")
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c(backtest_results$Backtest_Parameters$Backtest_Tag, backtest_results2$Backtest_Parameters$Backtest_Tag), col=1:2, lty=1:2)
my_params <- list("Backtest_Tag" = "NoAdj,WithRefit50",
"Model_XDataFile" = "Data/SmallTestFile.csv",
"XData_To_Use" = c("Returns", "PC1", "PC2"),
"Fit_Window" = 250,
"Rolling_Window_Performance" = 10,
"Prediction_Adjust_Factor" = 0.5,
"AdjustPredictedPositions" = FALSE,
"Classifier_Type" = "lda",
"Refit_Classifier_Periodicity" = 50)
my_params2 <- list("Backtest_Tag" = "WithAdj,WithRefit50",
"Model_XDataFile" = "Data/SmallTestFile.csv",
"XData_To_Use" = c("Returns", "PC1", "PC2"),
"Fit_Window" = 250,
"Rolling_Window_Performance" = 10,
"Prediction_Adjust_Factor" = 0.5,
"AdjustPredictedPositions" = TRUE,
"Classifier_Type" = "lda",
"Refit_Classifier_Periodicity" = 50)
backtest_results <- Backtest_ClassifierAlgo(my_params)
backtest_results2 <- Backtest_ClassifierAlgo(my_params2)
tmp_ccys <- config$Currencies
for (i in seq_along(tmp_ccys)) {
tmp_ccy <- tmp_ccys[i]
tmp <- backtest_results$Currency_Returns[[tmp_ccy]]; tmp[is.na(tmp)] <- 0
tmp2 <- backtest_results2$Currency_Returns[[tmp_ccy]]; tmp2[is.na(tmp2)] <- 0;
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main=paste(backtest_results$Backtest_Parameters$Backtest_Tag, backtest_results2$Backtest_Parameters$Backtest_Tag, tmp_ccy, sep=" : "))
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c(backtest_results$Backtest_Parameters$Backtest_Tag, backtest_results2$Backtest_Parameters$Backtest_Tag), col=1:2, lty=1:2)
}
tmp <- rowSums(backtest_results$Currency_Returns, na.rm=TRUE); tmp[is.na(tmp)] <- 0
tmp2 <- rowSums(backtest_results2$Currency_Returns, na.rm=TRUE); tmp2[is.na(tmp2)] <- 0
plot(cumsum(tmp), ylim=range(c(cumsum(tmp), cumsum(tmp2))), type="l", main="Aggregate")
lines(cumsum(tmp2), col="red", lty=2)
legend("topleft", legend=c(backtest_results$Backtest_Parameters$Backtest_Tag, backtest_results2$Backtest_Parameters$Backtest_Tag), col=1:2, lty=1:2)
inp_params <- my_params
outp_results <- list()  # List of backtest results and various calculated objects
classifiers_per_cross <- list()  # List object to hold trained classifiers for each cross, at each time (if using re-fitting)
# Add the backtest parameters list to the output list for user information
outp_results$Backtest_Parameters <- inp_params
# Import the XData file
# ---
Logger("Importing XData...")
model_xdata <- Get_XData(inp_params$Model_XDataFile)
outp_results$XData <- model_xdata
# ---
# Perform the initial classifier model fitting
# ---
Logger("Fitting initial classifier models...")
tmp_fit_date <- model_xdata$Datetime[inp_params$Fit_Window]
for (i in seq_along(config$Crosses)) {
cat("Currently on cross:", config$Crosses[i], "\n")
inp_params$Cross <- config$Crosses[i]
tmp_training_data <- head(model_xdata, inp_params$Fit_Window)
tmp_data <- Get_SubsetData_ForClassification(inp_data = tmp_training_data, inp_params = inp_params)
classifiers_per_cross[[config$Crosses[i]]][[tmp_fit_date]] <- Fit_Classifier(inp_data = tmp_data, inp_params = inp_params)
}
# ---
Logger("Performing backtest...")
# Initialise some data.frames to store data throughout iterations
tmp_predictions_raw <- data.frame(matrix(NA, nrow(model_xdata), length(config$Crosses), dimnames=list(model_xdata$Datetime, config$Crosses)))
tmp_predictions_adj <- data.frame(matrix(NA, nrow(model_xdata), length(config$Crosses), dimnames=list(model_xdata$Datetime, config$Crosses)))
tmp_predictions_accuracy <- data.frame(matrix(NA, nrow(model_xdata), length(config$Crosses), dimnames=list(model_xdata$Datetime, config$Crosses)))
tmp_predictions_accuracy_rolling <- data.frame(matrix(NA, nrow(model_xdata), length(config$Crosses), dimnames=list(model_xdata$Datetime, config$Crosses)))
tmp_currency_targets <- data.frame(matrix(NA, nrow(model_xdata), length(config$Currencies), dimnames=list(model_xdata$Datetime, config$Currencies)))
tmp_currency_returns <- data.frame(matrix(NA, nrow(model_xdata), length(config$Currencies), dimnames=list(model_xdata$Datetime, config$Currencies)))
# Extract concise array of cross returns for ease of use in backtester
cross_returns_array <- model_xdata[, c(1, match(paste(config$Crosses, ".1_Return", sep=""), names(model_xdata)))]  # Array of cross returns
colnames(cross_returns_array) <- c("Datetime", config$Crosses)  # Put better headers (excluding the .1_Return bit)
# Begin iterations through model_xdata (beyond initial classifier training data range), generating targets
time_since_fit <- 0
for (i in (inp_params$Fit_Window + 1):(inp_params$Fit_Window + 30)) {
# Progress print at set intervals
# ---
if (i %% 50 == 0)
Logger(paste("On date ", i, " of ", nrow(model_xdata), " ... ", sep=""))
# ---
# Section here to do something special like re-fit a model if certain criteria met
# ---
if (!is.na(inp_params$Refit_Classifier_Periodicity)) {  # Refit the classifier models here
# This should all live in a separate method, just to be called now
if (time_since_fit == inp_params$Refit_Classifier_Periodicity) {
Logger("Re-fitting classifier models...")
tmp_fit_date <- model_xdata$Datetime[i]
for (k in seq_along(config$Crosses)) {
cat("Currently on cross:", config$Crosses[k], "\n")
inp_params$Cross <- config$Crosses[k]
tmp_training_data <- model_xdata[(i - inp_params$Fit_Window):(i - 1), ]
tmp_data <- Get_SubsetData_ForClassification(inp_data = tmp_training_data, inp_params = inp_params)
classifiers_per_cross[[config$Crosses[k]]][[tmp_fit_date]] <- Fit_Classifier(inp_data = tmp_data, inp_params = inp_params)
}
time_since_fit <- 0
}
}
# ---
# Use xdata to classify the next day return
# ---
for (j in seq_along(config$Crosses)) {
tmp_cross <- config$Crosses[j]
# Get today data for classifier for this cross
inp_params$Cross <- tmp_cross
tmp_today_data <- Get_SubsetData_ForPrediction(inp_data = model_xdata[i, ], inp_params = inp_params)  # Current day xdata
# Get prediction and record the result as a 1 (buy) or -1 (sell)
tmp_today_predictions <- Get_ClassifierPrediction(classifiers_per_cross[[tmp_cross]][[length(classifiers_per_cross[[tmp_cross]])]], tmp_today_data, inp_params)   # Use latest classifier here (to take in to account any re-fitting done)
if (tmp_today_predictions$class == "B")
tmp_predictions_raw[i, j] <- 1
else if (tmp_today_predictions$class == "S")
tmp_predictions_raw[i, j] <- -1
# Record whether this was a correct prediction using next day cross return (if not already last row)
if (i < nrow(model_xdata))
tmp_predictions_accuracy[i, j] <- as.numeric(sign(tmp_predictions_raw[i, j]) == sign(cross_returns_array[[tmp_cross]][i + 1]))
# Calculate the rolling window prediction accuracy ratio (if sufficient predictions made) and create a performance-adjusted prediction
if (i > (inp_params$Fit_Window + inp_params$Rolling_Window_Performance)) {
tmp <- tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), j]  # Window of prediction accuracies for this cross
tmp_predictions_accuracy[i, j] <- sum(tmp == 1) / inp_params$Rolling_Window_Performance  # Accuracy ratio
tmp_predictions_adj[i, j] <- tmp_predictions_raw[i, j] * (1 + inp_params$Prediction_Adjust_Factor * (tmp_predictions_accuracy[i, j] - 0.5) / 0.5)
}
}
# ---
# Aggregate predictions to get currency level targets
# ---
for (j in seq_along(config$Currencies)) {
tmp_ccy <- config$Currencies[j]  # This currency
tmp_cxs_as_base <- config$Crosses[grep(tmp_ccy, substr(config$Crosses, 1, 3))]  # Crosses with the target ccy as base
tmp_cxs_as_quote <- config$Crosses[grep(tmp_ccy, substr(config$Crosses, 4, 6))]  # Crosses with the target ccy as quote
tmp_pos_as_base <- tmp_pos_as_quote <- 0  # Default values at 0
if (!all(is.na(tmp_predictions_adj[tmp_cxs_as_base][i, ])))
tmp_pos_as_base <- sum(tmp_predictions_adj[tmp_cxs_as_base][i, ], na.rm=TRUE)  # Sum of predictions where currency is base
if (!all(is.na(tmp_predictions_adj[tmp_cxs_as_quote][i, ])))
tmp_pos_as_quote <- sum(tmp_predictions_adj[tmp_cxs_as_quote][i, ], na.rm=TRUE)  # Sum of predictions where currency is quote
tmp_currency_targets[i, j] <- tmp_pos_as_base - tmp_pos_as_quote  # Total aggregated currency holding ("as quote" sum contributes as negative)
}
# ---
# Get resulting return from the target currency holdings
# ---
if (i < nrow(model_xdata)) {
for (j in seq_along(config$Currencies)) {
tmp_ccy <- config$Currencies[j]
if (tmp_ccy == "USD") {
tmp_currency_returns[i, j] <- 0
} else if (tmp_ccy %in% c("EUR", "GBP", "AUD", "NZD")) {
tmp_currency_returns[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * tmp_currency_targets[i, j]
} else {
tmp_currency_returns[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * tmp_currency_targets[i, j] * -1
}
}
}
# ---
time_since_fit <- time_since_fit + 1
}
i <- inp_params$Fit_Window + 31
if (i %% 50 == 0)
Logger(paste("On date ", i, " of ", nrow(model_xdata), " ... ", sep=""))
# ---
!is.na(inp_params$Refit_Classifier_Periodicity)
time_since_fit
inp_params$Refit_Classifier_Periodicity
time_since_fit == inp_params$Refit_Classifier_Periodicity
j<-1
tmp_cross <- config$Crosses[j]
# Get today data for classifier for this cross
inp_params$Cross <- tmp_cross
tmp_today_data <- Get_SubsetData_ForPrediction(inp_data = model_xdata[i, ], inp_params = inp_params)  # Current day xdata
tmp_today_data
tmp_today_predictions <- Get_ClassifierPrediction(classifiers_per_cross[[tmp_cross]][[length(classifiers_per_cross[[tmp_cross]])]], tmp_today_data, inp_params)   # Use latest classifier here (to take in to account any re-fitting done)
tmp_today_predictions
tmp_today_predictions$class == "B"
tmp_predictions_raw[i, j] <- 1
tmp_predictions_raw[i, j]
i < nrow(model_xdata)
tmp_predictions_accuracy[i, j] <- as.numeric(sign(tmp_predictions_raw[i, j]) == sign(cross_returns_array[[tmp_cross]][i + 1]))
tmp_predictions_accuracy[i, j]
tmp_predictions_raw[i, j]
sign(cross_returns_array[[tmp_cross]][i + 1])
cross_returns_array[[tmp_cross]][i + 1]
i > (inp_params$Fit_Window + inp_params$Rolling_Window_Performance)
tmp <- tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), j]  # Window of prediction accuracies for this cross
tmp
tmp_predictions_accuracy
inp_params$Rolling_Window_Performance
tmp_predictions_accuracy
all(is.na(tmp_predictions_accuracy))
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), j]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), 3]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), 5]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), 6]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), 7]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), 8]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), 9]
tmp_predictions_accuracy[(600 - inp_params$Rolling_Window_Performance):(600 - 1), 9]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance - 10):(i - 1), 9]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance - 10):(i - 1), 11]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance - 10):(i - 1), 13]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance - 10):(i - 1), 16]
tmp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance - 10):(i - 1), 18]
cross_returns_array
