{
    "contents" : "#methods.r\n\nLogger <- function(inp_string, inp_new_line=TRUE, inp_end_line=TRUE) {\n  \n  # Simple logger method that will produce debug info in an easy, structured manner\n  #\n  # Inputs:\n  #     inp_string:     string to be printed\n  #     inp_new_line:   boolean indicating whether this should be printed to a new line (TRUE) or current one (FALSE), default is TRUE \n  #     inp_end_line:   boolean indicating whether line should terminate at end of string (TRUE), or stay on current line (FALSE), default is TRUE \n  \n  # If need datetime stamp\n  if (inp_new_line)\n    tmp <- paste(\"< \", strftime(Sys.time(), \"%Y-%m-%d %H:%M:%OS\"),\" >\", sep=\"\")\n  else\n    tmp <- \"\"\n  # If need to terminate line at end\n  if (inp_end_line)\n    tmp <- paste(tmp, inp_string, \"\\n\", sep=\" \")\n  else\n    tmp <- paste(tmp, inp_string, sep=\" \")\n  \n  # print string\n  cat(tmp)\n  \n}\n\nGet_XData <- function(inp_filename) {\n  \n  # Read in X-data file and put in format required for further work (special column headers, etc...)\n  #\n  # Calls: NA\n  #\n  # Inputs:\n  #     inp_filename: string: filename for the X-dataset to read in\n  #\n  # Returns: dataframe containing the imported X-data\n  \n  \n  Logger(paste(\"Reading in data from file:\", inp_filename, \"...\", sep=\" \"), inp_end_line = FALSE)\n  \n  # Read the x-data array and the 2nd row containing the instrument type, to use in headers\n  tmp_data <- read.table(inp_filename, header=TRUE, sep=\",\", skip=2)\n  tmp <- read.csv(inp_filename, header=FALSE, skip=1, nrows=1, stringsAsFactors=FALSE)\n  \n  # Remove any extra columns at the end with NA's\n  tmp_na_columns <- which(is.na(tmp))\n  if (length(tmp_na_columns) > 0) {\n    tmp <- tmp[-tmp_na_columns]\n    tmp_data <- tmp_data[, -tmp_na_columns]\n  }\n    \n  # Add the column names to dataframe\n  tmp_names <- names(tmp_data)\n  names(tmp_data) <- paste(tmp_names, tmp, sep=\"_\")\n  \n  # Convert the first column (to be called \"Datetime\") to a nicer format\n  names(tmp_data)[1] <- \"Datetime\"\n  tmp_data$Datetime <- gsub(\"-\", \"-\", as.Date(tmp_data$Datetime, \"%d/%m/%Y\"))\n  \n  Logger(\"Complete!\", inp_new_line = FALSE)\n  \n  return (tmp_data)\n  \n}\n\nGet_CrossXDataColumns <- function(inp_params) {\n  \n  # Get X-data column headers to use for specified cross\n  #\n  # Calls: NA\n  #\n  # Inputs:\n  #     inp_params: list: list of backtest parameters\n  #\n  # Returns: vector of string column names\n  \n  ccy_base <- substr(inp_params$Cross, 1, 3); ccy_quote <- substr(inp_params$Cross, 4, 6)\n  outp_colnames <- c()\n  for (i in seq_along(inp_params$XData_To_Use)) {\n    if (inp_params$XData_To_Use[i] == \"Returns\") {  # Cross return\n      outp_colnames <- c(outp_colnames, paste(inp_params$Cross, \".1_Return\", sep=\"\"))\n    } else if (grepl(\"PC\", inp_params$XData_To_Use[i])) {  # A principal component\n      outp_colnames <- c(outp_colnames, paste(ccy_base, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Base ccy PC\n      outp_colnames <- c(outp_colnames, paste(ccy_quote, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Quote ccy PC\n    } else if (inp_params$XData_To_Use[i] == \"Index\") {\n      outp_colnames <- c(outp_colnames, paste(config$Market_Indices[[ccy_base]], \"EXO\", sep=\"_\"))  # Base ccy index\n      outp_colnames <- c(outp_colnames, paste(config$Market_Indices[[ccy_quote]], \"EXO\", sep=\"_\"))  # Quote ccy index\n    } else if (inp_params$XData_To_Use[i] %in% c(\"Copper\", \"Gold\", \"Crude\")) {\n      outp_colnames <- c(outp_colnames, paste(config$Market_Exos[[inp_params$XData_To_Use[i]]], \"EXO\", sep=\"_\"))\n    } \n  }\n  \n  return (outp_colnames)\n  \n}\n\nExtract_CrossTrainingXData <- function(inp_data, inp_params, inp_current_index) {\n  \n  # Extract a subset of data to use to train a classifier in a specific cross\n  #\n  # Calls: Get_CrossXDataColumns\n  #\n  # Inputs:\n  #     inp_data:           dataframe:  x-data from which we take a subset\n  #     inp_params:         list:       backtest parameters\n  #     inp_current_index:  numeric:    row/iteration of x-data that we are currently at\n  #\n  # Returns: dataframe subset of the xdata containing just columns relevant for the cross provided, and the required training set lookback window\n  \n  tmp_data <- inp_data[(inp_current_index - inp_params$Fit_Window):(inp_current_index - 1), ]  # Subset of historical data to use\n  cross_xdata_colnames <- Get_CrossXDataColumns(inp_params)  # XData columns to use\n  col_names_used_inds <- match(cross_xdata_colnames, names(tmp_data))  # Columns indices of XData columns\n  \n  # Get \"Group\" tag based on next day return (\"B\" if was up, \"S\" if was down)\n  tmp_groups <- rep(NA, nrow(tmp_data) - 1)  # -1 because we cannot put a group tag on last entry (no knowledge of realised next day return)\n  tmp <- tmp_data[[paste(inp_params$Cross, \".1_Return\", sep=\"\")]][-1]\n  tmp_groups[which(tmp < 0)] <- \"S\"\n  tmp_groups[which(tmp > 0)] <- \"B\"\n  \n  # Trim out the subset of data to contain only the required columns\n  outp_data <- data.frame(\"Group\"=tmp_groups, tmp_data[-nrow(tmp_data), col_names_used_inds])\n  \n  return (outp_data)\n  \n}\n\nExtract_CrossPredictionXData <- function(inp_data, inp_params, inp_current_index) {\n  \n  # Extract a subset of data (single row) to use to predict/classify a next-day return\n  #\n  # Calls: Get_CrossXDataColumns\n  #\n  # Inputs:\n  #     inp_data:           dataframe:  x-data from which we take a subset\n  #     inp_params:         list:       backtest parameters\n  #     inp_current_index:  numeric:    row/iteration of x-data that we are currently at\n  #\n  # Returns: dataframe subset (single row) of the x-data containing just columns relevant for the cross provided\n  \n  cross_xdata_colnames <- Get_CrossXDataColumns(inp_params)\n  col_names_used_inds <- match(cross_xdata_colnames, names(inp_data))\n  \n  # Trim out the subset of data to contain only the required columns\n  outp_data_sub <- inp_data[inp_current_index, col_names_used_inds]\n  \n  return (outp_data_sub)\n  \n}\n\nFit_Classifier <- function(inp_data, inp_params) {\n  \n  # Fit the classifier model to training data supplied, ready to use for future predictions\n  #\n  # Calls: NA\n  #\n  # Inputs:\n  #     inp_data:           dataframe:  training x-data\n  #     inp_params:         list:       backtest parameters\n  #\n  # Returns: a fitted classifier model object\n  \n  if (inp_params$Classifier_Type == \"lda\") {\n    tmp_model <- lda(Group ~ ., inp_data)\n  } else if (inp_params$Classifier_Type == \"qda\") {\n    tmp_model <- qda(Group ~ ., inp_data)\n  } else if (inp_params$Classifier_Type == \"nnet\") {\n    tmp_model <- NULL  # Not implemented yet\n  } else {\n    cat(\"Classifier:\", inp_params$Classifier_Type, \"not recognised...\\n\")\n    tmp_model <- NULL\n  }\n  \n  return (tmp_model)\n  \n}\n\nGet_ClassifierPrediction <- function(inp_classifier, inp_data, inp_params) {\n  \n  # Uses a supplied classifier model object and a set of x-data to produce a prediction/classification for next day return\n  #\n  # Calls: NA\n  #\n  # Inputs:\n  #     inp_classifier:  model object: fitted classifier model object\n  #     inp_data:           dataframe: training x-data\n  #     inp_params:              list: backtest parameters\n  #\n  # Returns: a fitted classifier model object\n  \n  tmp_prediciton <- predict(inp_classifier, newdata = inp_data)\n  return (tmp_prediciton)\n  \n}\n\nCalculate_AlgoPerformanceStats <- function(inp_backtest) {\n  \n  # Generates performance stats list for an backtested algorithm output\n  #\n  # Calls: NA\n  #\n  # Inputs:\n  #     inp_backtest:  backtest object: object returned by a backtest\n  #\n  # Returns: a list of stats summarising this backtest performance\n  \n  # TO DO\n  \n  return (NULL)\n  \n}",
    "created" : 1415200490887.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "2|70|25|0|\n27|37|64|0|\n66|47|95|0|\n97|81|125|0|\n127|83|148|0|\n150|50|175|0|\n177|76|193|0|\n195|58|210|0|\n",
    "hash" : "1845405509",
    "id" : "5E906A21",
    "lastKnownWriteTime" : 1415803233,
    "path" : "~/GitHub/PocketMoney/Algo_Classifiers/methods.R",
    "project_path" : "methods.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}