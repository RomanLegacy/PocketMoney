{
    "contents" : "#methods.r\n\n\nLog <- function(inp_string, inp_new_line=TRUE, inp_end_line=TRUE) {\n  \n  # Simple logger method that will produce debug info in an easy, structured manner\n  #\n  # Inputs:\n  #     inp_string:     string to be printed\n  #     inp_new_line:   boolean indicating whether this should be printed to a new line (TRUE) or current one (FALSE), default is TRUE \n  #     inp_end_line:   boolean indicating whether line should terminate at end of string (TRUE), or stay on current line (FALSE), default is TRUE \n  \n  # If need datetime stamp\n  if (inp_new_line)\n    tmp <- paste(\"< \", strftime(Sys.time(), \"%Y-%m-%d %H:%M:%OS\"),\" >\", sep=\"\")\n  else\n    tmp <- \"\"\n  # If need to terminate line at end\n  if (inp_end_line)\n    tmp <- paste(tmp, inp_string, \"\\n\", sep=\" \")\n  else\n    tmp <- paste(tmp, inp_string, sep=\" \")\n  \n  # print string\n  cat(tmp)\n  \n}\n\nGet_XData <- function(inp_filename) {\n  # Read in X-data file and put in format required for further work (special column headers, etc...)\n  \n  Log(paste(\"Reading in data from file:\", inp_filename, \"...\", sep=\" \"), inp_end_line = FALSE)\n  \n  tmp_data <- read.table(inp_filename, header=TRUE, sep=\",\", skip=2)\n  tmp <- read.csv(inp_filename, header=FALSE, skip=1, nrows=1, stringsAsFactors=FALSE)\n  tmpnames <- names(tmp_data)\n  names(tmp_data) <- paste(tmpnames, tmp, sep=\"_\")\n  \n  Log(\"Complete!\", inp_new_line = FALSE)\n  \n  return (tmp_data)\n  \n}\n\nGet_SubsetData_ForClassification <- function(inp_data, inp_params) {\n  # Strip out a subsetof the data that matches the specified securities, etc, for classification\n  \n  #   inp_data <- head(model_xdata, 1); inp_params <- my_params\n  \n  ccy_base <- substr(inp_params$Cross, 1, 3); ccy_quote <- substr(inp_params$Cross, 4, 6)\n  col_names_used <- c()\n  for (i in seq_along(inp_params$XData_To_Use)) {\n    if (inp_params$XData_To_Use[i] == \"Returns\") {  # Cross return\n      col_names_used <- c(col_names_used, paste(inp_params$Cross, \".1_Return\", sep=\"\"))\n    } else if (grepl(\"PC\", inp_params$XData_To_Use[i])) {  # A principal component\n      col_names_used <- c(col_names_used, paste(ccy_base, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Base ccy PC\n      col_names_used <- c(col_names_used, paste(ccy_quote, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Quote ccy PC\n    } else if (inp_params$XData_To_Use[i] == \"Index\") {\n      col_names_used <- c(col_names_used, paste(config$Market_Indices[[ccy_base]], \"EXO\", sep=\"_\"))  # Base ccy index\n      col_names_used <- c(col_names_used, paste(config$Market_Indices[[ccy_quote]], \"EXO\", sep=\"_\"))  # Quote ccy index\n    } else if (inp_params$XData_To_Use[i] %in% c(\"Copper\", \"Gold\", \"Crude\")) {\n      col_names_used <- c(col_names_used, paste(config$Market_Exos[[inp_params$XData_To_Use[i]]], \"EXO\", sep=\"_\"))\n    } \n  }\n  col_names_used_inds <- match(col_names_used, names(inp_data))\n  \n  # Get \"Group\" tag based on next day return (\"B\" if was up, \"S\" if was down)\n  tmp_groups <- rep(NA, nrow(inp_data) - 1)  # -1 because we cannot put a group tag on last entry\n  tmp <- inp_data[[paste(inp_params$Cross, \".1_Return\", sep=\"\")]][-1]\n  tmp_groups[which(tmp < 0)] <- \"S\"\n  tmp_groups[which(tmp > 0)] <- \"B\"\n  \n  # Trim out the subset of data to contain only the required columns\n  outp_data_sub <- data.frame(\"Group\"=tmp_groups, inp_data[-nrow(inp_data), col_names_used_inds])\n  \n  return (outp_data_sub)\n  \n}\n\nGet_SubsetData_ForPrediction <- function(inp_data, inp_params) {\n  # Strip out a subsetof the data that matches the specified securities, etc, for prediction\n  \n  #   inp_data <- head(model_xdata, 1); inp_params <- my_params\n  \n  ccy_base <- substr(inp_params$Cross, 1, 3); ccy_quote <- substr(inp_params$Cross, 4, 6)\n  col_names_used <- c()\n  for (i in seq_along(inp_params$XData_To_Use)) {\n    if (inp_params$XData_To_Use[i] == \"Returns\") {  # Cross return\n      col_names_used <- c(col_names_used, paste(inp_params$Cross, \".1_Return\", sep=\"\"))\n    } else if (grepl(\"PC\", inp_params$XData_To_Use[i])) {  # A principal component\n      col_names_used <- c(col_names_used, paste(ccy_base, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Base ccy PC\n      col_names_used <- c(col_names_used, paste(ccy_quote, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Quote ccy PC\n    } else if (inp_params$XData_To_Use[i] == \"Index\") {\n      col_names_used <- c(col_names_used, paste(config$Market_Indices[[ccy_base]], \"EXO\", sep=\"_\"))  # Base ccy index\n      col_names_used <- c(col_names_used, paste(config$Market_Indices[[ccy_quote]], \"EXO\", sep=\"_\"))  # Quote ccy index\n    } else if (inp_params$XData_To_Use[i] %in% c(\"Copper\", \"Gold\", \"Crude\")) {\n      col_names_used <- c(col_names_used, paste(config$Market_Exos[[inp_params$XData_To_Use[i]]], \"EXO\", sep=\"_\"))\n    } \n  }\n  col_names_used_inds <- match(col_names_used, names(inp_data))\n  \n  # Trim out the subset of data to contain only the required columns\n  outp_data_sub <- inp_data[1, col_names_used_inds]\n  \n  return (outp_data_sub)\n  \n}\n\nTest_Classifier <- function(inp_data, inp_params, inp_classifier_type, inp_print_results = TRUE) {\n  # Test classifier on subset data specified\n  \n  n_entries_training <- round(nrow(inp_data) * inp_params$Training_Size)\n  tmp_data_training <- head(inp_data, n_entries_training)\n  tmp_data_testing <- inp_data[-(1:n_entries_training), ]\n  \n  if (inp_classifier_type == \"lda\") {\n    \n    tmp_fit <- lda(Group ~ ., tmp_data_training)\n    tmp_preds <- predict(tmp_fit, newdata = tmp_data_testing)\n    tmp_conf_mat <- table(tmp_preds$class, tmp_data_testing$Group)\n    \n  } else if (inp_classifier_type == \"qda\") {\n    \n    tmp_fit <- qda(Group ~ ., tmp_data_training)\n    tmp_preds <- predict(tmp_fit, newdata = tmp_data_testing)\n    tmp_conf_mat <- table(tmp_preds$class, tmp_data_testing$Group)\n    \n  } else if (inp_classifier_type == \"nnet\") {\n    \n    cat(\"NNET not implemented yet...\\n\")\n    return (NULL)\n    #     tmp_fit <- nnet(Group ~ ., tmp_data_training, size = 4, decay = 0.1)\n    #     tmp_preds <- predict(tmp_fit, newdata = tmp_data_testing)\n    #     tmp_conf_mat <- table(tmp_preds$class, tmp_data_testing$Group)\n    \n  } else if (inp_classifier_type == \"knn\") {\n    \n    tmp_training_zeros <- which(as.numeric(rowSums(is.na(tmp_data_training) > 0)) > 0)  # Detect any NA values in dataset\n    if (length(tmp_training_zeros) > 0)\n      tmp_data_training <- tmp_data_training[-tmp_training_zeros, ]  # Trim out NA values in training set (knn won't work otherwise)\n    \n    tmp_preds <- knn(tmp_data_training[, -1], tmp_data_testing[, -1], tmp_data_training$Group, k = inp_params$Classifier$N_Neighbours, l = 0, prob = FALSE, use.all = TRUE)\n    tmp_conf_mat <- table(tmp_preds, tmp_data_testing$Group)\n    \n  } else {\n    cat(\"Classifier:\", inp_classifier_type, \"not recognised...\\n\")\n    return (NULL)\n  }\n  tmp_accuracy <- (tmp_conf_mat[1, 1] + tmp_conf_mat[2, 2]) / sum(tmp_conf_mat)\n  \n  if (inp_print_results) {\n    Log(paste(\"Classifier run = \", inp_classifier_type, \" , Cross = \", inp_params$Cross, sep=\"\"))\n    cat(paste(\"Independent variables used: \", paste(inp_params$XData_To_Use, collapse=\", \"), sep=\"\"))\n    cat(\"Percent correct classifications:\", tmp_accuracy, \"\\n\")\n    print(tmp_conf_mat)\n    cat(\"\\n\")\n  }\n  \n  \n  return (tmp_accuracy)\n  \n}\n\nFit_Classifier <- function(inp_data, inp_params) {\n  # Fit the classifier model to data supplied, returning the model, ready to use for future predictions\n  \n  if (inp_params$Classifier_Type == \"lda\") {\n    tmp_model <- lda(Group ~ ., inp_data)\n  } else if (inp_params$Classifier_Type == \"qda\") {\n    tmp_model <- qda(Group ~ ., inp_data)\n  } else if (inp_params$Classifier_Type == \"nnet\") {\n    tmp_model <- NULL  # Not implemented yet\n  } else {\n    cat(\"Classifier:\", inp_params$Classifier_Type, \"not recognised...\\n\")\n    tmp_model <- NULL\n  }\n  \n  return (tmp_model)\n  \n}\n\nGet_ClassifierPrediction <- function(inp_classifier, inp_data, inp_params) {\n  #inp_classifier <- classifiers_per_cross[[tmp_cross]]; inp_data <- tmp_today_data\n  tmp_prediciton <- predict(inp_classifier, newdata = inp_data)\n  return (tmp_prediciton)\n  \n}\n\nBacktest_ClassifierAlgo <- function(inp_params) {\n  # Perform a backtest of a specified classifier\n  #inp_params <- my_params\n  outp_results <- list()  # List of backtest results and various calculated objects\n  \n  # Import the XData file\n  # ---\n  Log(\"Importing XData...\")\n  model_xdata <- Get_XData(inp_params$Model_XDataFile)\n  outp_results$XData <- model_xdata\n  # ---\n  \n  \n  # Perform the initial classifier model fitting\n  # ---\n  Log(\"Fitting classifier models...\")\n  classifiers_per_cross <- list()\n  for (i in seq_along(config$Crosses)) {\n    cat(\"Currently on cross:\", config$Crosses[i], \"\\n\")\n    inp_params$Cross <- config$Crosses[i]\n    tmp_training_data <- head(model_xdata, inp_params$Fit_Window)\n    tmp_data <- Get_SubsetData_ForClassification(inp_data = tmp_training_data, inp_params = inp_params)\n    classifiers_per_cross[[config$Crosses[i]]] <- Fit_Classifier(inp_data = tmp_data, inp_params = inp_params)\n  }\n  outp_results$Cross_Classifiers <- classifiers_per_cross\n  # ---\n  \n  \n  # Iterate through all data\n  # ---\n  Log(\"Performing backtest...\")\n  \n  # Define all arrays of output information that we will generate during backtest\n  outp_predictions_raw <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Raw cross classifications\n  outp_predictions_adj <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Adjusted cross classifications\n  outp_predictions_accuracy <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Rolling prediction accuracy ratios\n  outp_rolling_accuracy <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Rolling prediction accuracy ratios\n  outp_currency_targets_raw <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Currency targets (aggregation of raw cross predictions)\n  outp_currency_targets_adj <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Currency targets (aggregation of adjusted cross predictions)\n  outp_aggregated_currency_returns_raw <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Returns from the raw target currency positions\n  outp_aggregated_currency_returns_adj <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Returns from the adjusted target currency positions\n  \n  # Extract concise array of cross returns for ease of use in backtester\n  cross_returns_array <- model_xdata[, c(1, match(paste(config$Crosses, \".1_Return\", sep=\"\"), names(model_xdata)))]  # Array of cross returns\n  colnames(cross_returns_array) <- c(\"Datetime\", config$Crosses)  # Put better headers (excluding the .1_Return bit)\n  \n  # Begin iterations through model_xdata (beyond initial classifier training data range), generating targets\n  for (i in (inp_params$Fit_Window + 1):nrow(model_xdata)) {\n    \n    if (i %% 50 == 0)\n      Log(paste(\"On date \", i, \" of \", nrow(model_xdata), \" ... \", sep=\"\"))\n    \n    # Get cross prediction/classifications for next day returns using current day xdata\n    for (j in seq_along(config$Crosses)) {\n      tmp_cross <- config$Crosses[j]\n      \n      # Get today data for classifier for this cross\n      inp_params$Cross <- tmp_cross\n      tmp_today_data <- Get_SubsetData_ForPrediction(inp_data = model_xdata[i, ], inp_params = inp_params)  # Current day xdata\n      \n      # Get prediction and record the result as a 1 (buy) or -1 (sell)\n      tmp_today_predictions <- Get_ClassifierPrediction(classifiers_per_cross[[tmp_cross]], tmp_today_data, inp_params) \n      if (tmp_today_predictions$class == \"B\")\n        outp_predictions_raw[i, j] <- 1\n      else if (tmp_today_predictions$class == \"S\")\n        outp_predictions_raw[i, j] <- -1\n      \n      # Record whether this was a correct prediction using next day cross return (if not already last row)\n      if (i < nrow(model_xdata))\n        outp_predictions_accuracy[i, j] <- as.numeric(sign(outp_predictions_raw[i, j]) == sign(cross_returns_array[[tmp_cross]][i + 1]))\n      \n      # Calculate the rolling window prediction accuracy ratio (if sufficient predictions made) and create a performance-adjusted prediction \n      if (i > (inp_params$Fit_Window + inp_params$Rolling_Window_Performance)) {\n        tmp <- outp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), j]  # Window of prediction accuracies for this cross\n        outp_rolling_accuracy[i, j] <- sum(tmp == 1) / inp_params$Rolling_Window_Performance  # Accuracy ratio      \n        outp_predictions_adj[i, j] <- outp_predictions_raw[i, j] * (1 + inp_params$Prediction_Adjust_Factor * (outp_rolling_accuracy[i, j] - 0.5) / 0.5)\n      }\n      \n    }\n    \n    # Aggregate all predictions to get currency level targets\n    for (j in seq_along(config$Currencies)) {\n      tmp_ccy <- config$Currencies[j]  # This currency\n      tmp_cols_as_base <- grep(tmp_ccy, substr(config$Crosses, 1, 3))  # Prediction columns where this currency is base ccy\n      tmp_cols_as_quote <- grep(tmp_ccy, substr(config$Crosses, 4, 6))  # Prediction columns where this currency is quote ccy\n      \n      # Get sum of preds where ccy appears as base currency \n      tmp_pos_as_base_raw <- sum(outp_predictions_raw[i, tmp_cols_as_base])  # (raw preds)\n      tmp_pos_as_base_adj <- sum(outp_predictions_adj[i, tmp_cols_as_base])  # (adj preds)\n      \n      # Get sum of preds where ccy appears as quote currency \n      tmp_pos_as_quote_raw <- sum(outp_predictions_raw[i, tmp_cols_as_quote])  # Row sums from where this currency appears as quote currency in cross (raw preds)\n      tmp_pos_as_quote_adj <- sum(outp_predictions_adj[i, tmp_cols_as_quote])  # Row sums from where this currency appears as quote currency in cross (adj preds)\n      \n      # Get total position from base and subtract total where appear as quote\n      outp_currency_targets_raw[i, j] <- tmp_pos_as_base_raw - tmp_pos_as_quote_raw  # Total aggregated currency holding, add \"from base\" contributions and subtract \"from quote\" contributions (RAW PREDS)\n      outp_currency_targets_adj[i, j] <- tmp_pos_as_base_adj - tmp_pos_as_quote_adj  # Total aggregated currency holding, add \"from base\" contributions and subtract \"from quote\" contributions (ADJ PREDS)\n      \n    }\n    \n    # Get resulting return from the target currency holdings\n    if (i < nrow(model_xdata)) {\n      for (j in seq_along(config$Currencies)) {\n        \n        tmp_ccy <- config$Currencies[j]\n        if (tmp_ccy == \"USD\") {\n          outp_aggregated_currency_returns_raw[i, j] <- 0\n          outp_aggregated_currency_returns_adj[i, j] <- 0\n        } else if (tmp_ccy %in% c(\"EUR\", \"GBP\", \"AUD\", \"NZD\")) {\n          outp_aggregated_currency_returns_raw[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_raw[i, j]\n          outp_aggregated_currency_returns_adj[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_adj[i, j]\n        } else {\n          outp_aggregated_currency_returns_raw[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_raw[i, j] * -1\n          outp_aggregated_currency_returns_adj[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_adj[i, j] * -1\n        }\n        \n        \n      }\n    }\n    \n  }\n  Log(\"Done!\", inp_new_line = FALSE)\n  \n  # Convert output arrays to dataframes and add to return list\n  # Predictions_raw\n  outp_predictions_raw <- data.frame(outp_predictions_raw)\n  colnames(outp_predictions_raw) <- config$Crosses; rownames(outp_predictions_raw) <- model_xdata[, 1]\n  outp_results$Predictions_Raw <- outp_predictions_raw\n  # Predictions_adj\n  outp_predictions_adj <- data.frame(outp_predictions_adj)\n  colnames(outp_predictions_adj) <- config$Crosses; rownames(outp_predictions_adj) <- model_xdata[, 1]\n  outp_results$Predictions_Adjusted <- outp_predictions_adj\n  # Predictions_accuracy\n  outp_predictions_accuracy <- data.frame(outp_predictions_accuracy)\n  colnames(outp_predictions_accuracy) <- config$Crosses; rownames(outp_predictions_accuracy) <- model_xdata[, 1]\n  outp_results$Predictions_Accuracy <- outp_predictions_accuracy\n  # Predictions_rolling_accuracy\n  outp_rolling_accuracy <- data.frame(outp_rolling_accuracy)\n  colnames(outp_rolling_accuracy) <- config$Crosses; rownames(outp_rolling_accuracy) <- model_xdata[, 1]\n  outp_results$Predictions_Rolling_Accuracy <- outp_rolling_accuracy\n  # Currency_targets_raw\n  outp_currency_targets_raw <- data.frame(outp_currency_targets_raw)\n  colnames(outp_currency_targets_raw) <- config$Currencies; rownames(outp_currency_targets_raw) <- model_xdata[, 1]\n  outp_results$Currency_Targets_Raw <- outp_currency_targets_raw\n  # Currency_targets_adj\n  outp_currency_targets_adj <- data.frame(outp_currency_targets_adj)\n  colnames(outp_currency_targets_adj) <- config$Currencies; rownames(outp_currency_targets_adj) <- model_xdata[, 1]\n  outp_results$Currency_Targets_Adjusted <- outp_currency_targets_adj\n  # Currency_target_returns_raw\n  outp_aggregated_currency_returns_raw <- data.frame(outp_aggregated_currency_returns_raw)\n  colnames(outp_aggregated_currency_returns_raw) <- config$Currencies; rownames(outp_aggregated_currency_returns_raw) <- model_xdata[, 1]\n  outp_results$Currency_Target_Returns_Raw <- outp_aggregated_currency_returns_raw\n  # Currency_target_returns_adj\n  outp_aggregated_currency_returns_adj <- data.frame(outp_aggregated_currency_returns_adj)\n  colnames(outp_aggregated_currency_returns_adj) <- config$Currencies; rownames(outp_aggregated_currency_returns_adj) <- model_xdata[, 1]\n  outp_results$Currency_Target_Returns_Adjusted <- outp_aggregated_currency_returns_adj\n  \n  return (outp_results)\n  \n}\n\nBacktest_ClassifierAlgo_WithRefits <- function(inp_params) {\n  # Perform a backtest of a specified classifier\n  #inp_params <- my_params\n  outp_results <- list()  # List of backtest results and various calculated objects\n  \n  # Import the XData file\n  # ---\n  Log(\"Importing XData...\")\n  model_xdata <- Get_XData(inp_params$Model_XDataFile)\n  outp_results$XData <- model_xdata\n  # ---\n  \n  \n  # Perform the initial classifier model fitting\n  # ---\n  Log(\"Fitting classifier models...\")\n  classifiers_per_cross <- list()\n  for (i in seq_along(config$Crosses)) {\n    cat(\"Currently on cross:\", config$Crosses[i], \"\\n\")\n    inp_params$Cross <- config$Crosses[i]\n    tmp_training_data <- head(model_xdata, inp_params$Fit_Window)\n    tmp_data <- Get_SubsetData_ForClassification(inp_data = tmp_training_data, inp_params = inp_params)\n    classifiers_per_cross[[config$Crosses[i]]] <- Fit_Classifier(inp_data = tmp_data, inp_params = inp_params)\n  }\n  outp_results$Cross_Classifiers <- classifiers_per_cross\n  # ---\n  \n  \n  # Iterate through all data\n  # ---\n  Log(\"Performing backtest...\")\n  \n  # Define all arrays of output information that we will generate during backtest\n  outp_predictions_raw <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Raw cross classifications\n  outp_predictions_adj <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Adjusted cross classifications\n  outp_predictions_accuracy <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Rolling prediction accuracy ratios\n  outp_rolling_accuracy <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Rolling prediction accuracy ratios\n  outp_currency_targets_raw <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Currency targets (aggregation of raw cross predictions)\n  outp_currency_targets_adj <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Currency targets (aggregation of adjusted cross predictions)\n  outp_aggregated_currency_returns_raw <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Returns from the raw target currency positions\n  outp_aggregated_currency_returns_adj <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Returns from the adjusted target currency positions\n  \n  # Extract concise array of cross returns for ease of use in backtester\n  cross_returns_array <- model_xdata[, c(1, match(paste(config$Crosses, \".1_Return\", sep=\"\"), names(model_xdata)))]  # Array of cross returns\n  colnames(cross_returns_array) <- c(\"Datetime\", config$Crosses)  # Put better headers (excluding the .1_Return bit)\n  \n  # Begin iterations through model_xdata (beyond initial classifier training data range), generating targets\n  time_to_refit <- inp_params$Classifier_Refit_Period\n  for (i in (inp_params$Fit_Window + 1):nrow(model_xdata)) {\n    if (i %% 50 == 0)\n      Log(paste(\"On date \", i, \" of \", nrow(model_xdata), \" ... \", sep=\"\"))\n    \n    \n    # Perform a re-fitting of the classifiers per cross if time_to_refit has reached 0\n    # ---\n    if (time_to_refit == 0) {\n      Log(\"Fitting classifier models...\")\n      classifiers_per_cross <- list()\n      for (k in seq_along(config$Crosses)) {\n        cat(\"Currently on cross:\", config$Crosses[k], \"\\n\")\n        inp_params$Cross <- config$Crosses[k]\n        tmp_training_data <- model_xdata[(i - inp_params$Fit_Window):(i - 1), ]\n        tmp_data <- Get_SubsetData_ForClassification(inp_data = tmp_training_data, inp_params = inp_params)\n        classifiers_per_cross[[config$Crosses[k]]] <- Fit_Classifier(inp_data = tmp_data, inp_params = inp_params)\n      }\n      outp_results$Cross_Classifiers <- classifiers_per_cross\n      time_to_refit <- inp_params$Classifier_Refit_Period\n    }\n    # ---\n    \n    # Get cross prediction/classifications for next day returns using current day xdata\n    for (j in seq_along(config$Crosses)) {\n      tmp_cross <- config$Crosses[j]\n      \n      # Get today data for classifier for this cross\n      inp_params$Cross <- tmp_cross\n      tmp_today_data <- Get_SubsetData_ForPrediction(inp_data = model_xdata[i, ], inp_params = inp_params)  # Current day xdata\n      \n      # Get prediction and record the result as a 1 (buy) or -1 (sell)\n      tmp_today_predictions <- Get_ClassifierPrediction(classifiers_per_cross[[tmp_cross]], tmp_today_data, inp_params) \n      if (tmp_today_predictions$class == \"B\")\n        outp_predictions_raw[i, j] <- 1\n      else if (tmp_today_predictions$class == \"S\")\n        outp_predictions_raw[i, j] <- -1\n      \n      # Record whether this was a correct prediction using next day cross return (if not already last row)\n      if (i < nrow(model_xdata))\n        outp_predictions_accuracy[i, j] <- as.numeric(sign(outp_predictions_raw[i, j]) == sign(cross_returns_array[[tmp_cross]][i + 1]))\n      \n      # Calculate the rolling window prediction accuracy ratio (if sufficient predictions made) and create a performance-adjusted prediction \n      if (i > (inp_params$Fit_Window + inp_params$Rolling_Window_Performance)) {\n        tmp <- outp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), j]  # Window of prediction accuracies for this cross\n        outp_rolling_accuracy[i, j] <- sum(tmp == 1) / inp_params$Rolling_Window_Performance  # Accuracy ratio      \n        outp_predictions_adj[i, j] <- outp_predictions_raw[i, j] * (1 + inp_params$Prediction_Adjust_Factor * (outp_rolling_accuracy[i, j] - 0.5) / 0.5)\n      }\n      \n    }\n    \n    # Aggregate all predictions to get currency level targets\n    for (j in seq_along(config$Currencies)) {\n      tmp_ccy <- config$Currencies[j]  # This currency\n      tmp_cols_as_base <- grep(tmp_ccy, substr(config$Crosses, 1, 3))  # Prediction columns where this currency is base ccy\n      tmp_cols_as_quote <- grep(tmp_ccy, substr(config$Crosses, 4, 6))  # Prediction columns where this currency is quote ccy\n      \n      # Get sum of preds where ccy appears as base currency \n      tmp_pos_as_base_raw <- sum(outp_predictions_raw[i, tmp_cols_as_base])  # (raw preds)\n      tmp_pos_as_base_adj <- sum(outp_predictions_adj[i, tmp_cols_as_base])  # (adj preds)\n      \n      # Get sum of preds where ccy appears as quote currency \n      tmp_pos_as_quote_raw <- sum(outp_predictions_raw[i, tmp_cols_as_quote])  # Row sums from where this currency appears as quote currency in cross (raw preds)\n      tmp_pos_as_quote_adj <- sum(outp_predictions_adj[i, tmp_cols_as_quote])  # Row sums from where this currency appears as quote currency in cross (adj preds)\n      \n      # Get total position from base and subtract total where appear as quote\n      outp_currency_targets_raw[i, j] <- tmp_pos_as_base_raw - tmp_pos_as_quote_raw  # Total aggregated currency holding, add \"from base\" contributions and subtract \"from quote\" contributions (RAW PREDS)\n      outp_currency_targets_adj[i, j] <- tmp_pos_as_base_adj - tmp_pos_as_quote_adj  # Total aggregated currency holding, add \"from base\" contributions and subtract \"from quote\" contributions (ADJ PREDS)\n      \n    }\n    \n    # Get resulting return from the target currency holdings\n    if (i < nrow(model_xdata)) {\n      for (j in seq_along(config$Currencies)) {\n        \n        tmp_ccy <- config$Currencies[j]\n        if (tmp_ccy == \"USD\") {\n          outp_aggregated_currency_returns_raw[i, j] <- 0\n          outp_aggregated_currency_returns_adj[i, j] <- 0\n        } else if (tmp_ccy %in% c(\"EUR\", \"GBP\", \"AUD\", \"NZD\")) {\n          outp_aggregated_currency_returns_raw[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_raw[i, j]\n          outp_aggregated_currency_returns_adj[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_adj[i, j]\n        } else {\n          outp_aggregated_currency_returns_raw[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_raw[i, j] * -1\n          outp_aggregated_currency_returns_adj[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_adj[i, j] * -1\n        }\n        \n        \n      }\n    }\n    \n    time_to_refit <- time_to_refit - 1\n    \n  }\n  Log(\"Done!\", inp_new_line = FALSE)\n  \n  # Convert output arrays to dataframes and add to return list\n  # Predictions_raw\n  outp_predictions_raw <- data.frame(outp_predictions_raw)\n  colnames(outp_predictions_raw) <- config$Crosses; rownames(outp_predictions_raw) <- model_xdata[, 1]\n  outp_results$Predictions_Raw <- outp_predictions_raw\n  # Predictions_adj\n  outp_predictions_adj <- data.frame(outp_predictions_adj)\n  colnames(outp_predictions_adj) <- config$Crosses; rownames(outp_predictions_adj) <- model_xdata[, 1]\n  outp_results$Predictions_Adjusted <- outp_predictions_adj\n  # Predictions_accuracy\n  outp_predictions_accuracy <- data.frame(outp_predictions_accuracy)\n  colnames(outp_predictions_accuracy) <- config$Crosses; rownames(outp_predictions_accuracy) <- model_xdata[, 1]\n  outp_results$Predictions_Accuracy <- outp_predictions_accuracy\n  # Predictions_rolling_accuracy\n  outp_rolling_accuracy <- data.frame(outp_rolling_accuracy)\n  colnames(outp_rolling_accuracy) <- config$Crosses; rownames(outp_rolling_accuracy) <- model_xdata[, 1]\n  outp_results$Predictions_Rolling_Accuracy <- outp_rolling_accuracy\n  # Currency_targets_raw\n  outp_currency_targets_raw <- data.frame(outp_currency_targets_raw)\n  colnames(outp_currency_targets_raw) <- config$Currencies; rownames(outp_currency_targets_raw) <- model_xdata[, 1]\n  outp_results$Currency_Targets_Raw <- outp_currency_targets_raw\n  # Currency_targets_adj\n  outp_currency_targets_adj <- data.frame(outp_currency_targets_adj)\n  colnames(outp_currency_targets_adj) <- config$Currencies; rownames(outp_currency_targets_adj) <- model_xdata[, 1]\n  outp_results$Currency_Targets_Adjusted <- outp_currency_targets_adj\n  # Currency_target_returns_raw\n  outp_aggregated_currency_returns_raw <- data.frame(outp_aggregated_currency_returns_raw)\n  colnames(outp_aggregated_currency_returns_raw) <- config$Currencies; rownames(outp_aggregated_currency_returns_raw) <- model_xdata[, 1]\n  outp_results$Currency_Target_Returns_Raw <- outp_aggregated_currency_returns_raw\n  # Currency_target_returns_adj\n  outp_aggregated_currency_returns_adj <- data.frame(outp_aggregated_currency_returns_adj)\n  colnames(outp_aggregated_currency_returns_adj) <- config$Currencies; rownames(outp_aggregated_currency_returns_adj) <- model_xdata[, 1]\n  outp_results$Currency_Target_Returns_Adjusted <- outp_aggregated_currency_returns_adj\n  \n  return (outp_results)\n  \n}\n\nBacktest_ClassifierAlgo_CrossSpecificClassifiers <- function(inp_params, inp_params_cross_specific_regression) {\n  # Perform a backtest of a specified classifier\n  #inp_params <- my_params\n  outp_results <- list()  # List of backtest results and various calculated objects\n  \n  # Import the XData file\n  # ---\n  Log(\"Importing XData...\")\n  model_xdata <- Get_XData(inp_params$Model_XDataFile)\n  outp_results$XData <- model_xdata\n  # ---\n  \n  \n  # Perform the initial classifier model fitting\n  # ---\n  Log(\"Fitting classifier models...\")\n  classifiers_per_cross <- list()\n  for (i in seq_along(config$Crosses)) {\n    cat(\"Currently on cross:\", config$Crosses[i], \"\\n\")\n    inp_params$Cross <- config$Crosses[i]\n    inp_params$XData_To_Use <- inp_params_cross_specific_regression[[config$Crosses[i]]]$XData_To_Use\n    inp_params$Classifier_Type <- inp_params_cross_specific_regression[[config$Crosses[i]]]$Classifier_Type\n    inp_params$Fit_Window <- inp_params_cross_specific_regression[[config$Crosses[i]]]$Fit_Window\n    tmp_training_data <- head(model_xdata, inp_params$Fit_Window)\n    tmp_data <- Get_SubsetData_ForClassification(inp_data = tmp_training_data, inp_params = inp_params)\n    classifiers_per_cross[[config$Crosses[i]]] <- Fit_Classifier(inp_data = tmp_data, inp_params = inp_params)\n  }\n  outp_results$Cross_Classifiers <- classifiers_per_cross\n  # ---\n  \n  \n  # Iterate through all data\n  # ---\n  Log(\"Performing backtest...\")\n  \n  # Define all arrays of output information that we will generate during backtest\n  outp_predictions_raw <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Raw cross classifications\n  outp_predictions_adj <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Adjusted cross classifications\n  outp_predictions_accuracy <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Rolling prediction accuracy ratios\n  outp_rolling_accuracy <- matrix(NA, nrow(model_xdata), length(config$Crosses))  # Rolling prediction accuracy ratios\n  outp_currency_targets_raw <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Currency targets (aggregation of raw cross predictions)\n  outp_currency_targets_adj <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Currency targets (aggregation of adjusted cross predictions)\n  outp_aggregated_currency_returns_raw <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Returns from the raw target currency positions\n  outp_aggregated_currency_returns_adj <- matrix(NA, nrow(model_xdata), length(config$Currencies))  # Returns from the adjusted target currency positions\n  \n  # Extract concise array of cross returns for ease of use in backtester\n  cross_returns_array <- model_xdata[, c(1, match(paste(config$Crosses, \".1_Return\", sep=\"\"), names(model_xdata)))]  # Array of cross returns\n  colnames(cross_returns_array) <- c(\"Datetime\", config$Crosses)  # Put better headers (excluding the .1_Return bit)\n  \n  # Begin iterations through model_xdata (beyond initial classifier training data range), generating targets\n  for (i in (inp_params$Fit_Window + 1):nrow(model_xdata)) {\n    \n    if (i %% 50 == 0)\n      Log(paste(\"On date \", i, \" of \", nrow(model_xdata), \" ... \", sep=\"\"))\n    \n    # Get cross prediction/classifications for next day returns using current day xdata\n    for (j in seq_along(config$Crosses)) {\n      tmp_cross <- config$Crosses[j]\n      \n      # Get today data for classifier for this cross\n      inp_params$Cross <- tmp_cross\n      inp_params$XData_To_Use <- inp_params_cross_specific_regression[[tmp_cross]]$XData_To_Use\n      inp_params$Classifier_Type <- inp_params_cross_specific_regression[[tmp_cross]]$Classifier_Type\n      inp_params$Fit_Window <- inp_params_cross_specific_regression[[tmp_cross]]$Fit_Window\n      tmp_today_data <- Get_SubsetData_ForPrediction(inp_data = model_xdata[i, ], inp_params = inp_params)  # Current day xdata\n      \n      # Get prediction and record the result as a 1 (buy) or -1 (sell)\n      tmp_today_predictions <- Get_ClassifierPrediction(classifiers_per_cross[[tmp_cross]], tmp_today_data, inp_params) \n      if (tmp_today_predictions$class == \"B\")\n        outp_predictions_raw[i, j] <- 1\n      else if (tmp_today_predictions$class == \"S\")\n        outp_predictions_raw[i, j] <- -1\n      \n      # Record whether this was a correct prediction using next day cross return (if not already last row)\n      if (i < nrow(model_xdata))\n        outp_predictions_accuracy[i, j] <- as.numeric(sign(outp_predictions_raw[i, j]) == sign(cross_returns_array[[tmp_cross]][i + 1]))\n      \n      # Calculate the rolling window prediction accuracy ratio (if sufficient predictions made) and create a performance-adjusted prediction \n      if (i > (inp_params$Fit_Window + inp_params$Rolling_Window_Performance)) {\n        tmp <- outp_predictions_accuracy[(i - inp_params$Rolling_Window_Performance):(i - 1), j]  # Window of prediction accuracies for this cross\n        outp_rolling_accuracy[i, j] <- sum(tmp == 1) / inp_params$Rolling_Window_Performance  # Accuracy ratio      \n        outp_predictions_adj[i, j] <- outp_predictions_raw[i, j] * (1 + inp_params$Prediction_Adjust_Factor * (outp_rolling_accuracy[i, j] - 0.5) / 0.5)\n      }\n      \n    }\n    \n    # Aggregate all predictions to get currency level targets\n    for (j in seq_along(config$Currencies)) {\n      tmp_ccy <- config$Currencies[j]  # This currency\n      tmp_cols_as_base <- grep(tmp_ccy, substr(config$Crosses, 1, 3))  # Prediction columns where this currency is base ccy\n      tmp_cols_as_quote <- grep(tmp_ccy, substr(config$Crosses, 4, 6))  # Prediction columns where this currency is quote ccy\n      \n      # Get sum of preds where ccy appears as base currency \n      tmp_pos_as_base_raw <- sum(outp_predictions_raw[i, tmp_cols_as_base])  # (raw preds)\n      tmp_pos_as_base_adj <- sum(outp_predictions_adj[i, tmp_cols_as_base])  # (adj preds)\n      \n      # Get sum of preds where ccy appears as quote currency \n      tmp_pos_as_quote_raw <- sum(outp_predictions_raw[i, tmp_cols_as_quote])  # Row sums from where this currency appears as quote currency in cross (raw preds)\n      tmp_pos_as_quote_adj <- sum(outp_predictions_adj[i, tmp_cols_as_quote])  # Row sums from where this currency appears as quote currency in cross (adj preds)\n      \n      # Get total position from base and subtract total where appear as quote\n      outp_currency_targets_raw[i, j] <- tmp_pos_as_base_raw - tmp_pos_as_quote_raw  # Total aggregated currency holding, add \"from base\" contributions and subtract \"from quote\" contributions (RAW PREDS)\n      outp_currency_targets_adj[i, j] <- tmp_pos_as_base_adj - tmp_pos_as_quote_adj  # Total aggregated currency holding, add \"from base\" contributions and subtract \"from quote\" contributions (ADJ PREDS)\n      \n    }\n    \n    # Get resulting return from the target currency holdings\n    if (i < nrow(model_xdata)) {\n      for (j in seq_along(config$Currencies)) {\n        \n        tmp_ccy <- config$Currencies[j]\n        if (tmp_ccy == \"USD\") {\n          outp_aggregated_currency_returns_raw[i, j] <- 0\n          outp_aggregated_currency_returns_adj[i, j] <- 0\n        } else if (tmp_ccy %in% c(\"EUR\", \"GBP\", \"AUD\", \"NZD\")) {\n          outp_aggregated_currency_returns_raw[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_raw[i, j]\n          outp_aggregated_currency_returns_adj[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_adj[i, j]\n        } else {\n          outp_aggregated_currency_returns_raw[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_raw[i, j] * -1\n          outp_aggregated_currency_returns_adj[i, j] <- cross_returns_array[[config$Currencies_To_USD[[tmp_ccy]]]][i + 1] * outp_currency_targets_adj[i, j] * -1\n        }\n        \n        \n      }\n    }\n    \n  }\n  Log(\"Done!\", inp_new_line = FALSE)\n  \n  # Convert output arrays to dataframes and add to return list\n  # Predictions_raw\n  outp_predictions_raw <- data.frame(outp_predictions_raw)\n  colnames(outp_predictions_raw) <- config$Crosses; rownames(outp_predictions_raw) <- model_xdata[, 1]\n  outp_results$Predictions_Raw <- outp_predictions_raw\n  # Predictions_adj\n  outp_predictions_adj <- data.frame(outp_predictions_adj)\n  colnames(outp_predictions_adj) <- config$Crosses; rownames(outp_predictions_adj) <- model_xdata[, 1]\n  outp_results$Predictions_Adjusted <- outp_predictions_adj\n  # Predictions_accuracy\n  outp_predictions_accuracy <- data.frame(outp_predictions_accuracy)\n  colnames(outp_predictions_accuracy) <- config$Crosses; rownames(outp_predictions_accuracy) <- model_xdata[, 1]\n  outp_results$Predictions_Accuracy <- outp_predictions_accuracy\n  # Predictions_rolling_accuracy\n  outp_rolling_accuracy <- data.frame(outp_rolling_accuracy)\n  colnames(outp_rolling_accuracy) <- config$Crosses; rownames(outp_rolling_accuracy) <- model_xdata[, 1]\n  outp_results$Predictions_Rolling_Accuracy <- outp_rolling_accuracy\n  # Currency_targets_raw\n  outp_currency_targets_raw <- data.frame(outp_currency_targets_raw)\n  colnames(outp_currency_targets_raw) <- config$Currencies; rownames(outp_currency_targets_raw) <- model_xdata[, 1]\n  outp_results$Currency_Targets_Raw <- outp_currency_targets_raw\n  # Currency_targets_adj\n  outp_currency_targets_adj <- data.frame(outp_currency_targets_adj)\n  colnames(outp_currency_targets_adj) <- config$Currencies; rownames(outp_currency_targets_adj) <- model_xdata[, 1]\n  outp_results$Currency_Targets_Adjusted <- outp_currency_targets_adj\n  # Currency_target_returns_raw\n  outp_aggregated_currency_returns_raw <- data.frame(outp_aggregated_currency_returns_raw)\n  colnames(outp_aggregated_currency_returns_raw) <- config$Currencies; rownames(outp_aggregated_currency_returns_raw) <- model_xdata[, 1]\n  outp_results$Currency_Target_Returns_Raw <- outp_aggregated_currency_returns_raw\n  # Currency_target_returns_adj\n  outp_aggregated_currency_returns_adj <- data.frame(outp_aggregated_currency_returns_adj)\n  colnames(outp_aggregated_currency_returns_adj) <- config$Currencies; rownames(outp_aggregated_currency_returns_adj) <- model_xdata[, 1]\n  outp_results$Currency_Target_Returns_Adjusted <- outp_aggregated_currency_returns_adj\n  \n  return (outp_results)\n  \n}",
    "created" : 1415200490887.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "3|67|26|0|\n28|37|42|0|\n44|68|77|0|\n79|64|106|0|\n108|98|161|0|\n163|50|179|0|\n181|76|186|0|\n188|49|347|0|\n349|60|528|0|\n530|112|695|0|\n",
    "hash" : "2942789312",
    "id" : "5E906A21",
    "lastKnownWriteTime" : 1415201308,
    "path" : "~/GitHub/PocketMoney/Algo_Classifiers/methods.R",
    "project_path" : "methods.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}