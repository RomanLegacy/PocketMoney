{
    "contents" : "#methods.r\n\nLogger <- function(inp_string, inp_new_line=TRUE, inp_end_line=TRUE) {\n  \n  # Simple logger method that will produce debug info in an easy, structured manner\n  #\n  # Inputs:\n  #     inp_string:     string to be printed\n  #     inp_new_line:   boolean indicating whether this should be printed to a new line (TRUE) or current one (FALSE), default is TRUE \n  #     inp_end_line:   boolean indicating whether line should terminate at end of string (TRUE), or stay on current line (FALSE), default is TRUE \n  \n  # If need datetime stamp\n  if (inp_new_line)\n    tmp <- paste(\"< \", strftime(Sys.time(), \"%Y-%m-%d %H:%M:%OS\"),\" >\", sep=\"\")\n  else\n    tmp <- \"\"\n  # If need to terminate line at end\n  if (inp_end_line)\n    tmp <- paste(tmp, inp_string, \"\\n\", sep=\" \")\n  else\n    tmp <- paste(tmp, inp_string, sep=\" \")\n  \n  # print string\n  cat(tmp)\n  \n}\n\nGet_XData <- function(inp_filename) {\n  # Read in X-data file and put in format required for further work (special column headers, etc...)\n  \n  Logger(paste(\"Reading in data from file:\", inp_filename, \"...\", sep=\" \"), inp_end_line = FALSE)\n  \n  tmp_data <- read.table(inp_filename, header=TRUE, sep=\",\", skip=2)\n  tmp <- read.csv(inp_filename, header=FALSE, skip=1, nrows=1, stringsAsFactors=FALSE)\n  tmpnames <- names(tmp_data)\n  names(tmp_data) <- paste(tmpnames, tmp, sep=\"_\")\n  \n  Logger(\"Complete!\", inp_new_line = FALSE)\n  \n  return (tmp_data)\n  \n}\n\nGet_SubsetData_ForClassification <- function(inp_data, inp_params) {\n  # Strip out a subsetof the data that matches the specified securities, etc, for classification\n  \n  #   inp_data <- head(model_xdata, 1); inp_params <- my_params\n  \n  ccy_base <- substr(inp_params$Cross, 1, 3); ccy_quote <- substr(inp_params$Cross, 4, 6)\n  col_names_used <- c()\n  for (i in seq_along(inp_params$XData_To_Use)) {\n    if (inp_params$XData_To_Use[i] == \"Returns\") {  # Cross return\n      col_names_used <- c(col_names_used, paste(inp_params$Cross, \".1_Return\", sep=\"\"))\n    } else if (grepl(\"PC\", inp_params$XData_To_Use[i])) {  # A principal component\n      col_names_used <- c(col_names_used, paste(ccy_base, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Base ccy PC\n      col_names_used <- c(col_names_used, paste(ccy_quote, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Quote ccy PC\n    } else if (inp_params$XData_To_Use[i] == \"Index\") {\n      col_names_used <- c(col_names_used, paste(config$Market_Indices[[ccy_base]], \"EXO\", sep=\"_\"))  # Base ccy index\n      col_names_used <- c(col_names_used, paste(config$Market_Indices[[ccy_quote]], \"EXO\", sep=\"_\"))  # Quote ccy index\n    } else if (inp_params$XData_To_Use[i] %in% c(\"Copper\", \"Gold\", \"Crude\")) {\n      col_names_used <- c(col_names_used, paste(config$Market_Exos[[inp_params$XData_To_Use[i]]], \"EXO\", sep=\"_\"))\n    } \n  }\n  col_names_used_inds <- match(col_names_used, names(inp_data))\n  \n  # Get \"Group\" tag based on next day return (\"B\" if was up, \"S\" if was down)\n  tmp_groups <- rep(NA, nrow(inp_data) - 1)  # -1 because we cannot put a group tag on last entry\n  tmp <- inp_data[[paste(inp_params$Cross, \".1_Return\", sep=\"\")]][-1]\n  tmp_groups[which(tmp < 0)] <- \"S\"\n  tmp_groups[which(tmp > 0)] <- \"B\"\n  \n  # Trim out the subset of data to contain only the required columns\n  outp_data_sub <- data.frame(\"Group\"=tmp_groups, inp_data[-nrow(inp_data), col_names_used_inds])\n  \n  return (outp_data_sub)\n  \n}\n\n# Checked to here...\n\nGet_SubsetData_ForPrediction <- function(inp_data, inp_params) {\n  # Strip out a subsetof the data that matches the specified securities, etc, for prediction\n  \n  #   inp_data <- head(model_xdata, 1); inp_params <- my_params\n  \n  ccy_base <- substr(inp_params$Cross, 1, 3); ccy_quote <- substr(inp_params$Cross, 4, 6)\n  col_names_used <- c()\n  for (i in seq_along(inp_params$XData_To_Use)) {\n    if (inp_params$XData_To_Use[i] == \"Returns\") {  # Cross return\n      col_names_used <- c(col_names_used, paste(inp_params$Cross, \".1_Return\", sep=\"\"))\n    } else if (grepl(\"PC\", inp_params$XData_To_Use[i])) {  # A principal component\n      col_names_used <- c(col_names_used, paste(ccy_base, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Base ccy PC\n      col_names_used <- c(col_names_used, paste(ccy_quote, inp_params$XData_To_Use[i], \"_PC\", sep=\"\"))  # Quote ccy PC\n    } else if (inp_params$XData_To_Use[i] == \"Index\") {\n      col_names_used <- c(col_names_used, paste(config$Market_Indices[[ccy_base]], \"EXO\", sep=\"_\"))  # Base ccy index\n      col_names_used <- c(col_names_used, paste(config$Market_Indices[[ccy_quote]], \"EXO\", sep=\"_\"))  # Quote ccy index\n    } else if (inp_params$XData_To_Use[i] %in% c(\"Copper\", \"Gold\", \"Crude\")) {\n      col_names_used <- c(col_names_used, paste(config$Market_Exos[[inp_params$XData_To_Use[i]]], \"EXO\", sep=\"_\"))\n    } \n  }\n  col_names_used_inds <- match(col_names_used, names(inp_data))\n  \n  # Trim out the subset of data to contain only the required columns\n  outp_data_sub <- inp_data[1, col_names_used_inds]\n  \n  return (outp_data_sub)\n  \n}\n\nTest_Classifier <- function(inp_data, inp_params, inp_classifier_type, inp_print_results = TRUE) {\n  # Test classifier on subset data specified\n  \n  n_entries_training <- round(nrow(inp_data) * inp_params$Training_Size)\n  tmp_data_training <- head(inp_data, n_entries_training)\n  tmp_data_testing <- inp_data[-(1:n_entries_training), ]\n  \n  if (inp_classifier_type == \"lda\") {\n    \n    tmp_fit <- lda(Group ~ ., tmp_data_training)\n    tmp_preds <- predict(tmp_fit, newdata = tmp_data_testing)\n    tmp_conf_mat <- table(tmp_preds$class, tmp_data_testing$Group)\n    \n  } else if (inp_classifier_type == \"qda\") {\n    \n    tmp_fit <- qda(Group ~ ., tmp_data_training)\n    tmp_preds <- predict(tmp_fit, newdata = tmp_data_testing)\n    tmp_conf_mat <- table(tmp_preds$class, tmp_data_testing$Group)\n    \n  } else if (inp_classifier_type == \"nnet\") {\n    \n    cat(\"NNET not implemented yet...\\n\")\n    return (NULL)\n    #     tmp_fit <- nnet(Group ~ ., tmp_data_training, size = 4, decay = 0.1)\n    #     tmp_preds <- predict(tmp_fit, newdata = tmp_data_testing)\n    #     tmp_conf_mat <- table(tmp_preds$class, tmp_data_testing$Group)\n    \n  } else if (inp_classifier_type == \"knn\") {\n    \n    tmp_training_zeros <- which(as.numeric(rowSums(is.na(tmp_data_training) > 0)) > 0)  # Detect any NA values in dataset\n    if (length(tmp_training_zeros) > 0)\n      tmp_data_training <- tmp_data_training[-tmp_training_zeros, ]  # Trim out NA values in training set (knn won't work otherwise)\n    \n    tmp_preds <- knn(tmp_data_training[, -1], tmp_data_testing[, -1], tmp_data_training$Group, k = inp_params$Classifier$N_Neighbours, l = 0, prob = FALSE, use.all = TRUE)\n    tmp_conf_mat <- table(tmp_preds, tmp_data_testing$Group)\n    \n  } else {\n    cat(\"Classifier:\", inp_classifier_type, \"not recognised...\\n\")\n    return (NULL)\n  }\n  tmp_accuracy <- (tmp_conf_mat[1, 1] + tmp_conf_mat[2, 2]) / sum(tmp_conf_mat)\n  \n  if (inp_print_results) {\n    Logger(paste(\"Classifier run = \", inp_classifier_type, \" , Cross = \", inp_params$Cross, sep=\"\"))\n    cat(paste(\"Independent variables used: \", paste(inp_params$XData_To_Use, collapse=\", \"), sep=\"\"))\n    cat(\"Percent correct classifications:\", tmp_accuracy, \"\\n\")\n    print(tmp_conf_mat)\n    cat(\"\\n\")\n  }\n  \n  \n  return (tmp_accuracy)\n  \n}\n\nFit_Classifier <- function(inp_data, inp_params) {\n  # Fit the classifier model to data supplied, returning the model, ready to use for future predictions\n  \n  if (inp_params$Classifier_Type == \"lda\") {\n    tmp_model <- lda(Group ~ ., inp_data)\n  } else if (inp_params$Classifier_Type == \"qda\") {\n    tmp_model <- qda(Group ~ ., inp_data)\n  } else if (inp_params$Classifier_Type == \"nnet\") {\n    tmp_model <- NULL  # Not implemented yet\n  } else {\n    cat(\"Classifier:\", inp_params$Classifier_Type, \"not recognised...\\n\")\n    tmp_model <- NULL\n  }\n  \n  return (tmp_model)\n  \n}\n\nGet_ClassifierPrediction <- function(inp_classifier, inp_data, inp_params) {\n  #inp_classifier <- classifiers_per_cross[[tmp_cross]]; inp_data <- tmp_today_data\n  tmp_prediciton <- predict(inp_classifier, newdata = inp_data)\n  return (tmp_prediciton)\n  \n}\n\n",
    "created" : 1415200490887.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "27|37|41|0|\n43|68|76|0|\n80|64|107|0|\n164|50|180|0|\n182|76|187|0|\n",
    "hash" : "453844699",
    "id" : "5E906A21",
    "lastKnownWriteTime" : 1415283577,
    "path" : "~/GitHub/PocketMoney/Algo_Classifiers/methods.R",
    "project_path" : "methods.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}